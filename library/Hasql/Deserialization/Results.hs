-- |
-- An API for retrieval of multiple results.
-- Can be used to handle:
-- 
-- * A single result,
-- 
-- * Individual results of a multi-statement query
-- with the help of "Applicative" and "Monad",
-- 
-- * Row-by-row fetching.
-- 
module Hasql.Deserialization.Results where

import Hasql.Prelude hiding (maybe, many)
import qualified Database.PostgreSQL.LibPQ as LibPQ
import qualified Hasql.Prelude as Prelude
import qualified Hasql.Deserialization.Result as Result
import qualified Hasql.Deserialization.Row as Row


newtype Results a =
  Results (ReaderT (Bool, LibPQ.Connection) (EitherT Error IO) a)
  deriving (Functor, Applicative, Monad)

data Error =
  -- |
  -- An error on the client-side,
  -- with a message generated by the \"libpq\" library.
  -- Usually indicates problems with the connection.
  ClientError !(Maybe ByteString) |
  ResultError !Result.Error

{-# INLINE run #-}
run :: Results a -> (Bool, LibPQ.Connection) -> IO (Either Error a)
run (Results stack) env =
  runEitherT (runReaderT stack env)

clientError :: Results a
clientError =
  Results $ ReaderT $ \(_, connection) -> EitherT $
  fmap (Left . ClientError) (LibPQ.errorMessage connection)

-- |
-- Parse a single result.
{-# INLINE single #-}
single :: Result.Result a -> Results a
single resultDes =
  Results $ ReaderT $ \(integerDatetimes, connection) -> EitherT $ do
    resultMaybe <- LibPQ.getResult connection
    case resultMaybe of
      Just result ->
        fmap (mapLeft ResultError) (Result.run resultDes (integerDatetimes, result))
      Nothing ->
        fmap (Left . ClientError) (LibPQ.errorMessage connection)

-- |
-- Fetch a single result.
{-# INLINABLE getResult #-}
getResult :: Results LibPQ.Result
getResult =
  Results $ ReaderT $ \(_, connection) -> EitherT $ do
    resultMaybe <- LibPQ.getResult connection
    case resultMaybe of
      Just result -> pure (Right result)
      Nothing -> fmap (Left . ClientError) (LibPQ.errorMessage connection)

-- |
-- Fetch a single result.
{-# INLINABLE getResultMaybe #-}
getResultMaybe :: Results (Maybe LibPQ.Result)
getResultMaybe =
  Results $ ReaderT $ \(_, connection) -> lift $ LibPQ.getResult connection

{-# INLINABLE dropRemainders #-}
dropRemainders :: Results ()
dropRemainders =
  Results $ ReaderT $ \(integerDatetimes, connection) -> loop integerDatetimes connection
  where
    loop integerDatetimes connection =
      getResultMaybe >>= Prelude.maybe (pure ()) onResult
      where
        getResultMaybe =
          lift $ LibPQ.getResult connection
        onResult result =
          checkErrors *> loop integerDatetimes connection
          where
            checkErrors =
              EitherT $ fmap (mapLeft ResultError) $ Result.run Result.unit (integerDatetimes, result)

cancel :: Results ()
cancel =
  undefined
